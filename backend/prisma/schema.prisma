// ─────────────────────────────────────────────────────────────────
//  FleetFlow — Production-Ready Prisma Schema
//  PostgreSQL | Prisma ORM | Modular Fleet & Logistics System
//  Design: 3NF normalized, enum-driven state machines, indexed for
//          dashboard-level analytic queries and dispatch operations.
//  DB conventions (per db-architecture-agent):
//    • All PK/FK BigInts use @db.BigInt
//    • Every field has @map("snake_case") to decouple Prisma names
//      from PostgreSQL column names — enabling idiomatic TS API while
//      keeping a clean snake_case schema in the database.
//    • Timestamptz used throughout for timezone-aware storage
// ─────────────────────────────────────────────────────────────────

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ─────────────────────────────────────────────────────────────────
//  ENUMS — All lifecycle states and categorical types live here.
//  Never use raw strings for controlled vocabularies.
// ─────────────────────────────────────────────────────────────────

/// Roles aligned to operational domains in FleetFlow.
enum UserRole {
  SUPER_ADMIN      // Full system access — god mode
  MANAGER          // Fleet oversight, read analytics, approve actions
  DISPATCHER       // Create / manage trips and assignments
  SAFETY_OFFICER   // Driver credentials, vehicle inspections, incident logs
  FINANCE_ANALYST  // Revenue, expenses, fuel logs, reporting
}

/// Physical vehicle category — governs capacity rules and compliance.
enum VehicleType {
  TRUCK
  VAN
  BIKE
  PLANE
}

/// Vehicle operational state machine.
/// AVAILABLE → ON_TRIP → AVAILABLE
/// AVAILABLE → IN_SHOP → AVAILABLE
/// * → RETIRED (terminal, irreversible)
enum VehicleStatus {
  AVAILABLE
  ON_TRIP
  IN_SHOP
  RETIRED
}

/// Driver duty and availability state machine.
/// OFF_DUTY → ON_DUTY → ON_TRIP → ON_DUTY
/// ON_DUTY | OFF_DUTY → SUSPENDED (blocks all dispatch)
enum DriverStatus {
  ON_DUTY
  OFF_DUTY
  ON_TRIP
  SUSPENDED
}

/// Trip lifecycle — strict directional transitions enforced in service layer.
/// DRAFT → DISPATCHED → COMPLETED
/// DRAFT | DISPATCHED → CANCELLED (terminal)
enum TripStatus {
  DRAFT
  DISPATCHED
  COMPLETED
  CANCELLED
}

/// Expense classification for financial reporting and ledger grouping.
enum ExpenseCategory {
  TOLL
  LODGING
  MAINTENANCE_EN_ROUTE
  MISC
}

/// Immutable audit trail action types.
enum AuditAction {
  CREATE
  UPDATE
  DELETE
}

// ─────────────────────────────────────────────────────────────────
//  MODEL: User
//  System user — authenticated principal for all API interactions.
//  Role stored inline (denormalized) for fast single-row auth checks.
// ─────────────────────────────────────────────────────────────────

model User {
  id           BigInt    @id @default(autoincrement()) @db.BigInt
  email        String    @unique
  passwordHash String    @map("password_hash")    // bcrypt hash, min 60 chars
  fullName     String    @map("full_name")
  role         UserRole  @default(DISPATCHER)
  isActive     Boolean   @default(true) @map("is_active")
  createdAt    DateTime  @default(now()) @db.Timestamptz() @map("created_at")
  updatedAt    DateTime  @updatedAt @db.Timestamptz() @map("updated_at")

  // Relations
  auditLogs    AuditLog[]

  @@index([email])
  @@index([role])
  @@index([isActive])
  @@map("users")
}

// ─────────────────────────────────────────────────────────────────
//  MODEL: VehicleTypeRecord
//  Lookup / metadata table for each vehicle type.
//  Allows adding type-specific notes, compliance requirements etc.
// ─────────────────────────────────────────────────────────────────

model VehicleTypeRecord {
  id          BigInt      @id @default(autoincrement()) @db.BigInt
  name        VehicleType @unique
  description String?
  createdAt   DateTime    @default(now()) @db.Timestamptz() @map("created_at")
  updatedAt   DateTime    @updatedAt @db.Timestamptz() @map("updated_at")

  // Relations
  vehicles    Vehicle[]

  @@map("vehicle_types")
}

// ─────────────────────────────────────────────────────────────────
//  MODEL: Vehicle
//  Core fleet asset. Never hard-deleted — uses is_deleted soft flag.
//  Odometer only ever increases (enforced in service layer + trigger).
// ─────────────────────────────────────────────────────────────────

model Vehicle {
  id               BigInt        @id @default(autoincrement()) @db.BigInt
  licensePlate     String        @unique @map("license_plate")
  make             String        // e.g. "Peterbilt"
  model            String        // e.g. "579"
  year             Int
  color            String?
  vin              String?       @unique @map("vin") // Vehicle Identification Number

  // Type (FK to VehicleTypeRecord lookup)
  vehicleTypeId    BigInt        @db.BigInt @map("vehicle_type_id")
  vehicleType      VehicleTypeRecord @relation(fields: [vehicleTypeId], references: [id], onDelete: Restrict)

  // Operational state
  status           VehicleStatus @default(AVAILABLE)

  // Odometer (km) — monotonically increasing, fraud-guarded in service layer
  currentOdometer  Decimal       @default(0) @db.Decimal(15, 2) @map("current_odometer")

  // Capacity specs (set per deployment)
  capacityWeight   Decimal?      @db.Decimal(10, 2) @map("capacity_weight") // kg or tons
  capacityVolume   Decimal?      @db.Decimal(10, 2) @map("capacity_volume") // m³ or cubic ft

  // Soft delete — preserves referential integrity for historical trips
  isDeleted        Boolean       @default(false) @map("is_deleted")
  deletedAt        DateTime?     @db.Timestamptz() @map("deleted_at")

  createdAt        DateTime      @default(now()) @db.Timestamptz() @map("created_at")
  updatedAt        DateTime      @updatedAt @db.Timestamptz() @map("updated_at")

  // Relations (Restrict prevents orphaning historical data)
  trips            Trip[]            @relation("VehicleTrips")
  fuelLogs         FuelLog[]         @relation("VehicleFuelLogs")
  maintenanceLogs  MaintenanceLog[]  @relation("VehicleMaintenanceLogs")
  expenses         Expense[]         @relation("VehicleExpenses")
  locations        VehicleLocation[] @relation("VehicleLocations")

  // Indexes for hot query paths
  @@index([status])                     // Filter AVAILABLE vehicles for dispatch
  @@index([isDeleted])                  // Exclude soft-deleted from list queries
  @@index([vehicleTypeId])
  @@index([status, isDeleted])          // Composite: Active + available dispatch pool
  @@map("vehicles")
}

// ─────────────────────────────────────────────────────────────────
//  MODEL: Driver
//  Operational personnel. License expiry critical for compliance.
//  Safety score starts at 100 and decrements per infraction model.
// ─────────────────────────────────────────────────────────────────

model Driver {
  id                BigInt        @id @default(autoincrement()) @db.BigInt
  licenseNumber     String        @unique @map("license_number")
  fullName          String        @map("full_name")
  phone             String?
  email             String?       @unique
  dateOfBirth       DateTime?     @db.Date @map("date_of_birth")

  // License & compliance
  licenseExpiryDate DateTime      @db.Date @map("license_expiry_date")
  licenseClass      String?       @map("license_class") // e.g. "CDL-A", "B2"

  // Operational state
  status            DriverStatus  @default(OFF_DUTY)

  // Safety scoring — starts at 100, decremented by Safety Officer
  safetyScore       Decimal       @default(100) @db.Decimal(5, 2) @map("safety_score")

  // Soft delete — preserves historical trip assignments
  isDeleted         Boolean       @default(false) @map("is_deleted")
  deletedAt         DateTime?     @db.Timestamptz() @map("deleted_at")

  createdAt         DateTime      @default(now()) @db.Timestamptz() @map("created_at")
  updatedAt         DateTime      @updatedAt @db.Timestamptz() @map("updated_at")

  // Relations
  trips             Trip[]        @relation("DriverTrips")

  // Indexes for dispatch query paths
  @@index([status])                       // Rapid ON_DUTY driver pool query
  @@index([isDeleted])
  @@index([licenseExpiryDate])            // Cron job scans for expiring licenses
  @@index([status, isDeleted])            // Active driver dispatch pool
  @@map("drivers")
}

// ─────────────────────────────────────────────────────────────────
//  MODEL: Trip
//  Core dispatch entity. State machine strictly enforced in service.
//  Financial summary (revenue) stored inline for fast ledger queries.
//  Odometer range (start/end) enables per-trip distance calculations.
// ─────────────────────────────────────────────────────────────────

model Trip {
  id                BigInt     @id @default(autoincrement()) @db.BigInt

  // Asset assignments (Restrict — can't delete vehicle/driver with trips)
  vehicleId         BigInt     @db.BigInt @map("vehicle_id")
  vehicle           Vehicle    @relation("VehicleTrips", fields: [vehicleId], references: [id], onDelete: Restrict)

  driverId          BigInt     @db.BigInt @map("driver_id")
  driver            Driver     @relation("DriverTrips", fields: [driverId], references: [id], onDelete: Restrict)

  // Route information
  origin            String
  destination       String
  distanceEstimated Decimal    @db.Decimal(10, 2) @map("distance_estimated")   // km
  distanceActual    Decimal?   @db.Decimal(10, 2) @map("distance_actual")      // km — filled on COMPLETED

  // Cargo
  cargoWeight       Decimal?   @db.Decimal(10, 2) @map("cargo_weight")         // kg — validated against vehicle capacity
  cargoDescription  String?    @map("cargo_description")

  // Odometer snapshot at dispatch and completion
  odometerStart     Decimal?   @db.Decimal(15, 2) @map("odometer_start")
  odometerEnd       Decimal?   @db.Decimal(15, 2) @map("odometer_end")

  // Financial
  revenue           Decimal?   @db.Decimal(15, 2)                              // Gross revenue for this trip
  clientName        String?    @map("client_name")
  invoiceReference  String?    @unique @map("invoice_reference")               // Unique per invoice

  // State machine
  status            TripStatus @default(DRAFT)

  // Timestamps for state transitions
  dispatchTime      DateTime?  @db.Timestamptz() @map("dispatch_time")           // Set when → DISPATCHED
  completionTime    DateTime?  @db.Timestamptz() @map("completion_time")         // Set when → COMPLETED

  // Optional cancellation tracking
  cancelledReason   String?    @map("cancelled_reason")

  createdAt         DateTime   @default(now()) @db.Timestamptz() @map("created_at")
  updatedAt         DateTime   @updatedAt @db.Timestamptz() @map("updated_at")

  // Child financial records (Cascade — trip owns their logs)
  fuelLogs          FuelLog[]  @relation("TripFuelLogs")
  expenses          Expense[]  @relation("TripExpenses")

  // Composite indexes for dashboard and dispatch queries
  @@index([vehicleId, status])       // "What is this vehicle doing?"
  @@index([driverId, status])        // "What is this driver doing?"
  @@index([status])                  // Active trips board
  @@index([createdAt])               // Time-range reports
  @@index([dispatchTime])            // Utilization window aggregations
  @@map("trips")
}

// ─────────────────────────────────────────────────────────────────
//  MODEL: FuelLog
//  Tracks every fuel fill event per vehicle, optionally per trip.
//  total_cost = liters * cost_per_liter (enforced in service layer).
//  odometer_at_fill must be >= vehicle.current_odometer (anti-fraud).
// ─────────────────────────────────────────────────────────────────

model FuelLog {
  id             BigInt   @id @default(autoincrement()) @db.BigInt

  // Always linked to a vehicle
  vehicleId      BigInt   @db.BigInt @map("vehicle_id")
  vehicle        Vehicle  @relation("VehicleFuelLogs", fields: [vehicleId], references: [id], onDelete: Restrict)

  // Optionally linked to the active trip at time of fill
  tripId         BigInt?  @db.BigInt @map("trip_id")
  trip           Trip?    @relation("TripFuelLogs", fields: [tripId], references: [id], onDelete: SetNull)

  // Fill details
  liters         Decimal  @db.Decimal(10, 2)             // > 0
  costPerLiter   Decimal  @db.Decimal(10, 4) @map("cost_per_liter") // > 0, 4dp for precision
  totalCost      Decimal  @db.Decimal(15, 2) @map("total_cost")     // = liters * cost_per_liter

  // Odometer at time of fill — monotonically increasing, fraud detection
  odometerAtFill Decimal  @db.Decimal(15, 2) @map("odometer_at_fill")

  fuelStation    String?  @map("fuel_station")  // Station name / location
  loggedAt       DateTime @default(now()) @db.Timestamptz() @map("logged_at")
  createdAt      DateTime @default(now()) @db.Timestamptz() @map("created_at")
  updatedAt      DateTime @updatedAt @db.Timestamptz() @map("updated_at")

  @@index([vehicleId])
  @@index([tripId])
  @@index([loggedAt])   // Time-range fuel cost aggregation
  @@map("fuel_logs")
}

// ─────────────────────────────────────────────────────────────────
//  MODEL: MaintenanceLog
//  All service events for a vehicle. Closing a maintenance log
//  triggers IN_SHOP → AVAILABLE transition in service layer.
// ─────────────────────────────────────────────────────────────────

model MaintenanceLog {
  id                BigInt   @id @default(autoincrement()) @db.BigInt

  vehicleId         BigInt   @db.BigInt @map("vehicle_id")
  vehicle           Vehicle  @relation("VehicleMaintenanceLogs", fields: [vehicleId], references: [id], onDelete: Restrict)

  serviceType       String   @map("service_type") // e.g. "OIL_CHANGE", "BRAKE_INSPECTION"
  description       String?  @db.Text
  cost              Decimal  @db.Decimal(15, 2)   // >= 0
  odometerAtService Decimal  @db.Decimal(15, 2) @map("odometer_at_service") // >= vehicle.current_odometer

  // Technician / shop details
  technicianName    String?  @map("technician_name")
  shopName          String?  @map("shop_name")

  // Temporal
  serviceDate       DateTime  @db.Timestamptz() @map("service_date")
  nextServiceDue    DateTime? @db.Timestamptz() @map("next_service_due") // Optional — schedule next service
  createdAt         DateTime  @default(now()) @db.Timestamptz() @map("created_at")
  updatedAt         DateTime  @updatedAt @db.Timestamptz() @map("updated_at")

  @@index([vehicleId])
  @@index([serviceDate])
  @@index([nextServiceDue])   // Cron job scans for upcoming scheduled services
  @@map("maintenance_logs")
}

// ─────────────────────────────────────────────────────────────────
//  MODEL: Expense
//  Operational expenses — linked to vehicle and optionally a trip.
//  Amount >= 0 enforced in service layer + CHECK constraint.
// ─────────────────────────────────────────────────────────────────

model Expense {
  id             BigInt          @id @default(autoincrement()) @db.BigInt

  // Always linked to a vehicle
  vehicleId      BigInt          @db.BigInt @map("vehicle_id")
  vehicle        Vehicle         @relation("VehicleExpenses", fields: [vehicleId], references: [id], onDelete: Restrict)

  // Optionally linked to a specific trip
  tripId         BigInt?         @db.BigInt @map("trip_id")
  trip           Trip?           @relation("TripExpenses", fields: [tripId], references: [id], onDelete: SetNull)

  amount         Decimal         @db.Decimal(15, 2)
  category       ExpenseCategory
  description    String?

  // Who logged this (denormalized for audit speed — no join needed)
  loggedByUserId BigInt?         @db.BigInt @map("logged_by_user_id")

  dateLogged     DateTime        @default(now()) @db.Timestamptz() @map("date_logged")
  createdAt      DateTime        @default(now()) @db.Timestamptz() @map("created_at")
  updatedAt      DateTime        @updatedAt @db.Timestamptz() @map("updated_at")

  @@index([vehicleId])
  @@index([tripId])
  @@index([category])
  @@index([dateLogged])
  @@index([loggedByUserId])     // "All expenses logged by user X" — FK must be indexed per agent rules
  @@map("expenses")
}

// ─────────────────────────────────────────────────────────────────
//  MODEL: VehicleLocation
//  Real-time GPS telemetry. Written every N seconds via IoT/mobile.
//  recorded_at indexed DESC — "latest location" query is O(log n).
//  Partition by vehicle_id in production for massive datasets.
// ─────────────────────────────────────────────────────────────────

model VehicleLocation {
  id          BigInt   @id @default(autoincrement()) @db.BigInt

  vehicleId   BigInt   @db.BigInt @map("vehicle_id")
  vehicle     Vehicle  @relation("VehicleLocations", fields: [vehicleId], references: [id], onDelete: Cascade)

  latitude    Decimal  @db.Decimal(10, 7)   // -90 to +90, 7dp ≈ 1cm precision
  longitude   Decimal  @db.Decimal(11, 7)   // -180 to +180
  speed       Decimal? @db.Decimal(6, 2)    // km/h — optional

  // Optional heading and accuracy from GPS sensor
  heading     Decimal? @db.Decimal(5, 2)    // 0-360 degrees
  accuracy    Decimal? @db.Decimal(6, 2)    // meters

  recordedAt  DateTime @default(now()) @db.Timestamptz() @map("recorded_at")

  // Primary access pattern: latest ping per vehicle
  @@index([vehicleId, recordedAt(sort: Desc)])
  @@index([recordedAt])
  @@map("vehicle_locations")
}

// ─────────────────────────────────────────────────────────────────
//  MODEL: AuditLog
//  Immutable append-only audit trail. Never updated or deleted.
//  old_values / new_values store full JSON diffs for forensic replay.
//  Every state-mutating service operation inserts a row here.
// ─────────────────────────────────────────────────────────────────

model AuditLog {
  id         BigInt      @id @default(autoincrement()) @db.BigInt

  // Actor — SetNull if user is deactivated (preserves log integrity)
  userId     BigInt?     @db.BigInt @map("user_id")
  user       User?       @relation(fields: [userId], references: [id], onDelete: SetNull)

  // Target entity information
  entity     String      // e.g. "Trip", "Vehicle", "Driver"
  entityId   BigInt      @db.BigInt @map("entity_id") // PK of the affected row

  // Action type
  action     AuditAction

  // Full JSON diffs — null on CREATE (no old) / DELETE (no new)
  oldValues  Json?       @map("old_values")
  newValues  Json?       @map("new_values")

  // Optional reason provided by the actor (required for CANCELLED trips etc.)
  reason     String?     @db.Text

  // IP and user agent for security forensics
  ipAddress  String?     @map("ip_address")
  userAgent  String?     @map("user_agent")

  // Immutable timestamp — never has updatedAt
  timestamp  DateTime    @default(now()) @db.Timestamptz()

  @@index([userId])
  @@index([entity, entityId])   // "Show all changes to Vehicle #42"
  @@index([entity])
  @@index([timestamp])          // Time-range audit lookups
  @@map("audit_logs")
}
